<html>
<head>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="Stylesheet" type="text/css" href="../style.css" />
    <title>2020 ICPC East Central NA Regional Contest 总结与题解</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../highlight/styles/nord.css">
    <script src="../highlight/highlight.pack.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre').forEach((block) => {
                hljs.highlightBlock(block);
            });
        });
    </script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
    <div class="header">
        <a href="posts.html">← All Posts</a>
        <small>2021-03-10</small>
    </div>
    <hr>

    
<div id="Contents" class="toc"><h1 id="Contents">Contents</a></h1></div>
<ul>
<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解">2020 ICPC East Central NA Regional Contest 总结与题解</a>

<ul>
<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-比赛过程">比赛过程</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-反思">反思</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解">题解</a>

<ul>
<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-A">A</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-B">B</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-C">C</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-D">D</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-E">E</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-F">F</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-G">G</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-H">H</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-I">I</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-J">J</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-K">K</a>

<li>
<a href="ECNA2020.html#2020 ICPC East Central NA Regional Contest 总结与题解-题解-L">L</a>

</ul>
</ul>
</ul>

<p>
<span id="-题解/Tutorial"></span><span class="tag" id="题解/Tutorial">题解/Tutorial</span>
</p>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解"><h1 id="2020 ICPC East Central NA Regional Contest 总结与题解" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解">2020 ICPC East Central NA Regional Contest 总结与题解</a></h1></div>

<p>
算是有所进步但还是稍有遗憾，差一题就能进division championships (update: 靠外卡进了233)
</p>


<div id="2020 ICPC East Central NA Regional Contest 总结与题解-比赛过程"><h2 id="比赛过程" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-比赛过程">比赛过程</a></h2></div>

<p>
两个队友一个简称T，一个简称J。
</p>

<p>
开场我从前往后读，A比较长就直接跳过了，读了B感觉有点想法但又不是很确定就接着读，C很明显是个找最大环，一开始还觉得比较麻烦，但想想不是环就是链所以直接dfs就行了。同时队友J读到E发现就是个矩阵乘法于是开始写，我又跟榜做了G。之后不久队友J的E也过了。另一个队友T读了H是贪心但不会写，我此时在写B的暴力（但其实稍微想想暴力肯定超时但不知道为啥还是写完了）。B暴力写完才发现会超时，此时H还没做出来，我看了一眼也没想法，就扔给队友J了。然后发现B好像可以dp，然后就一边想一边写，虽然有点恶心但挺直接的，最后一遍过。写B的过程中队友J过了H，算是签完到了。此时才一个半小时，感觉非常好，比去年顺利多了。
</p>

<p>
然后我在做K，感觉是dp，有点思路但不会写，队友J在做J，过了样例但是WA，队友T直接开I了（其实是最难的题orz）。于是三个人都卡题了，不知不觉过了一个半小时我终于放弃了，此时J题过了一大堆，于是我就跟队友J换了一下题，由于队友J用的python而我又懒的看所以就准备重写，然后没想到是个超级恶心模拟题，而且写了一堆bug，离结束还有半小时和队友J几乎同时过了J和K。然后仔细一看A发现很简单但输出格式很恶心，最后虽然勉强写完但没时间debug，以7题收场。
</p>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-反思"><h2 id="反思" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-反思">反思</a></h2></div>

<p>
卡题太久没有及时放弃，哪怕去读读别的题。题没有都读一遍，队友J其实读了A但感觉很麻烦，但我感觉比J好做多了（可能我J写的太烂了）。L到最后也没人读，其实也不难，就是个二分图匹配的板子 题。所以说也不能一味的跟榜，毕竟每个人的知识点覆盖不一样。但K卡半天没做出来也不应该。
</p>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解"><h2 id="题解" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解">题解</a></h2></div>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-A"><h3 id="A" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-A">A</a></h3></div>

<p>
数据很小，找lca直接暴力网上跳也可以。输出格式比较恶心，要多看几遍，注意不要把<code>11th, 12th, 13th</code>输出成 <code>11st, 12nd, 13rd</code>。
</p>

<pre>
#include &lt;bits/stdc++.h&gt;

#define all(x) (x).begin(),(x).end()
#define sz(x) int(x.size())

using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
template&lt;typename... T&gt; void rd(T&amp;... args) {((cin&gt;&gt;args), ...);}
template&lt;typename... T&gt; void wr(T... args) {((cout&lt;&lt;args&lt;&lt;" "), ...); cout&lt;&lt;'\n';}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, T;
    cin&gt;&gt;n&gt;&gt;T;
    vector&lt;vector&lt;string&gt;&gt; a(n);
    vector&lt;string&gt; name(n);
    unordered_map&lt;string, int&gt; id;
    for (int i=0; i&lt;n; i++) {
        cin&gt;&gt;name[i];
        id.try_emplace(name[i], id.size());
        int x;
        cin&gt;&gt;x;
        a[i].resize(x);
        for (auto&amp; s : a[i]) {
            cin&gt;&gt;s;
            id.try_emplace(s, id.size());
        }
    }
    vector&lt;vector&lt;int&gt;&gt; g(id.size());
    vector&lt;int&gt; ind(id.size());
    for (int i=0; i&lt;n; i++) {
        int u=id[name[i]];
        for (auto&amp; s : a[i]) {
            g[u].push_back(id[s]);
            ind[id[s]]++;
        }
    }
    vector&lt;int&gt; pa(id.size());
    vector&lt;int&gt; dep(id.size());
    auto dfs=[&amp;](auto&amp; dfs, int u, int p) -&gt; void {
        pa[u] = p;
        for (auto v : g[u]) {
            if (v == p) continue;
            dep[v]=dep[u]+1;
            dfs(dfs, v, u);
        }
    };

    auto lca=[&amp;](int x, int y) {
        while (x!=y) {
            if (dep[x]&lt;dep[y]) swap(x, y);
            x=pa[x];
        }
        return x;
    };

    for (int i=0; i&lt;id.size(); i++) {
        if (ind[i]==0) {
            dfs(dfs, i, i);
            break;
        }
    }
    auto ordinal=[](int x) {
        auto s=to_string(x);
        if (x&gt;=11 &amp;&amp; x&lt;=13) return s+"th";
        if (x%10==1) return s+"st";
        if (x%10==2) return s+"nd";
        if (x%10==3) return s+"rd";
        return s+"th";
    };
    while (T--) {
        string s, t;
        cin&gt;&gt;s&gt;&gt;t;
        int l=lca(id[s], id[t]);
        int m=dep[id[s]]-dep[l];
        int n=dep[id[t]]-dep[l];
        int swaped=0;
        if (m&gt;n) {
            swap(m, n);
            swaped=1;
            swap(s, t);
        }
        if (m==0) {
            swap(s, t);
            if (n==1) {
                cout&lt;&lt;s&lt;&lt;" is the child of "&lt;&lt;t&lt;&lt;'\n';
            } else {
                n-=2;
                cout&lt;&lt;s&lt;&lt;" is the ";
                for (int i=0; i&lt;n; i++) cout&lt;&lt;"great ";
                cout&lt;&lt;"grandchild of "&lt;&lt;t&lt;&lt;'\n';
            }
        } else if (m==n &amp;&amp; m&gt;0) {
            if (swaped) swap(s, t);
            if (n==1) cout&lt;&lt;s&lt;&lt;" and "&lt;&lt;t&lt;&lt;" are siblings\n";
            else {
                n--;
                cout&lt;&lt;s&lt;&lt;" and "&lt;&lt;t&lt;&lt;" are "&lt;&lt;ordinal(n)&lt;&lt;" cousins\n";
            }
        } else if (n&gt;m &amp;&amp; m&gt;0) {
            if (swaped) swap(s, t);
            if (n-m==1)
                cout&lt;&lt;s&lt;&lt;" and "&lt;&lt;t&lt;&lt;" are "&lt;&lt; ordinal(m-1)&lt;&lt;" cousins, 1 time removed\n";
            else 
                cout&lt;&lt;s&lt;&lt;" and "&lt;&lt;t&lt;&lt;" are "&lt;&lt;ordinal(m-1)&lt;&lt;" cousins, "&lt;&lt;n-m&lt;&lt;" times removed\n";
        }
    }
        return 0;
}
</pre>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-B"><h3 id="B" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-B">B</a></h3></div>

<p>
<code>dp[x][y][i][used][d]</code> 代表是否存在以坐标\((x, y)\) 的字符结尾，覆盖目标字符串的前<code>i</code>个字符，转向<code>used</code>次，结束时的方向是<code>d</code>的走法。注意长度为\(i\)的字符串最多转\(i-1\)次，虽然第一个字符是没有方向的，但为了转移方便就变成了所有方向，所以枚举转向次数的话要限制一下，不然会出现长度为2转两次的走法。
</p>

<pre>
#include &lt;bits/stdc++.h&gt;

#define all(x) (x).begin(),(x).end()
#define sz(x) int(x.size())

using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
template&lt;typename... T&gt; void rd(T&amp;... args) {((cin&gt;&gt;args), ...);}
template&lt;typename... T&gt; void wr(T... args) {((cout&lt;&lt;args&lt;&lt;" "), ...); cout&lt;&lt;'\n';}

int dp[10][10][105][105][8];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    cin&gt;&gt;n&gt;&gt;m;
    vector a(n, vector&lt;char&gt;(m));
    for (int i=0; i&lt;n; i++) {
        for (int j=0; j&lt;m; j++) {
            cin&gt;&gt;a[i][j];
        }
    }
    int limit;
    string s;
    cin&gt;&gt;limit&gt;&gt;s;
    limit=min(limit, int(s.size()));
    const vector&lt;pair&lt;int, int&gt;&gt; dirs{{1, 0}, {-1, 0}, {0,1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
    for (int i=0; i&lt;n; i++) {
        for (int j=0; j&lt;m; j++) {
            if (a[i][j]==s[0]) {
                for (int d=0; d&lt;8; d++) 
                    dp[i][j][0][0][d]=1;
            }
        }
    }
    for (int i=1; i&lt;s.size(); i++) {
        for (int x=0; x&lt;n; x++) {
            for (int y=0; y&lt;m; y++) {
                if (a[x][y]!=s[i]) continue;
                for (int used=0; used&lt;=min(limit, i-1); used++) {
                    for (int d=0; d&lt;8; d++) {
                        for (int pd=0; pd&lt;8; pd++) {
                            auto [dx, dy]=dirs[d];
                            unsigned nx=x+dx, ny=y+dy;
                            int pused=used-(d!=pd);
                            // if (i==1) pused=0;
                            if (nx&lt;n &amp;&amp; ny&lt;m &amp;&amp; pused&gt;=0 &amp;&amp; dp[nx][ny][i-1][pused][pd]) {
                                dp[x][y][i][used][d]=1;
                            }
                        }
                    }
                }
            }
        }
    }
    for (int i=0; i&lt;n; i++) {
        for (int j=0; j&lt;m; j++) {
            for (int d=0; d&lt;8; d++)
                if (dp[i][j][s.size()-1][limit][d]) 
                    return cout&lt;&lt;"Yes", 0;
        }
    }
    cout&lt;&lt;"No";
    return 0;
}
</pre>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-C"><h3 id="C" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-C">C</a></h3></div>

<p>
由于每个物品最多只有一个人要，所以每个点的出度最多为1，所以每个连通分量要么是环要么是链。直接dfs即可。
</p>

<pre>
#include &lt;bits/stdc++.h&gt;

#define all(x) (x).begin(),(x).end()
#define sz(x) int(x.size())

using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
template&lt;typename... T&gt; void rd(T&amp;... args) {((cin&gt;&gt;args), ...);}
template&lt;typename... T&gt; void wr(T... args) {((cout&lt;&lt;args&lt;&lt;" "), ...); cout&lt;&lt;'\n';}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin&gt;&gt;n;
    vector&lt;vector&lt;int&gt;&gt; g(n);
    struct node {
        string name, has, wants;
    };
    vector&lt;node&gt; a(n);
    unordered_map&lt;string, int&gt; names, toys;
    unordered_map&lt;string, string&gt; wanted_by;
    for (auto&amp; [name, has, wants] : a) {
        cin&gt;&gt;name&gt;&gt;has&gt;&gt;wants;
        names.try_emplace(name, names.size());
        toys.try_emplace(has, toys.size());
        toys.try_emplace(wants, toys.size());
        wanted_by[wants]=name;
    }
    for (int i=0; i&lt;n; i++) {
        if (wanted_by.count(a[i].has))
            g[i].push_back(names[wanted_by[a[i].has]]);
    }
    vector&lt;int&gt; vis(n);
    int ans=0;
    auto dfs=[&amp;](auto&amp; dfs, int u, int dep) -&gt; void{
        vis[u]=1;
        for (auto v : g[u]) {
            if (vis[v]==1) {
                ans=max(ans, dep+1);
            } else {
                dfs(dfs, v, dep+1);
            }
        }
        vis[u]=2;
    };
    for (int i=0; i&lt;n; i++) {
        if (!vis[i]) {
            dfs(dfs, i, 0);
        }
    }
    if (ans) cout&lt;&lt;ans;
    else cout&lt;&lt;"No trades possible";
    return 0;
}
</pre>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-D"><h3 id="D" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-D">D</a></h3></div>

<p>
还没来得及补
</p>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-E"><h3 id="E" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-E">E</a></h3></div>

<p>
非常简单的矩阵乘法，队友写的，没要代码。。。
</p>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-F"><h3 id="F" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-F">F</a></h3></div>

<p>
矩阵求逆，模运算下的高斯消元。队友赛后补的
</p>

<pre>
using namespace std;
#include &lt;bits/stdc++.h&gt;
#include &lt;string&gt;
#define ll long long
#define all(x) (x).begin(),(x).end()
#define sz(x) int(x.size())
#define rep(i, a, b) for(int i = a; i &lt; (b); ++i)
#define FOR(i,n) for(int (i)=0;(i)&lt;(n);++(i))
#define PRE(i,m,n,in) for(int (i)=(m);(i)&lt;(n);i+=in)
#define RPRE(i,m,n,in) for(int (i)=(m);(i)&gt;=(n);i-=in)
#define srt(v) sort(v.begin(),v.end())
#define printv(a) printa(a,0,a.size())
#define debug(x) cout&lt;&lt;#x" = "&lt;&lt;(x)&lt;&lt;endl
#define printa(a,L,R) for(int i=L;i&lt;R;i++) cout&lt;&lt;a[i]&lt;&lt;(i==R-1?"\n":" ")
#define printv(a) printa(a,0,a.size())
#define print2d(a,r,c) for(int i=0;i&lt;r;i++) for(int j=0;j&lt;c;j++) cout&lt;&lt;a[i][j]&lt;&lt;(j==c-1?"\n":" ")
typedef vector&lt;string&gt;VS;
typedef pair&lt;int,int&gt;pii;
typedef pair&lt;ll,ll&gt;pll;
typedef vector&lt;ll&gt;VL;
typedef vector&lt;int&gt;VI;
typedef vector&lt;VI&gt;VVI;
typedef vector&lt;VL&gt;VVL;
typedef vector&lt;pii&gt;VII;

const int MOD = 37;
const int INF = 2; 

int gauss (vector &lt; vector&lt;int&gt; &gt; &amp;a, vector&lt;int&gt; &amp; ans, const vector&lt;ll&gt;&amp;inv) {
  int n = (int) a.size(); int m = (int) a[0].size() - 1;
  vector&lt;int&gt; where (m, -1);
  for (int col=0, row=0; col&lt;m &amp;&amp; row&lt;n; ++col) {
    int sel = row;
    for (int i=row; i&lt;n; ++i)
      if ( a[i][col] &gt; a[sel][col]) sel = i;
    if (a[sel][col] == 0) continue;
    for (int i=col; i&lt;=m; ++i)
      swap (a[sel][i], a[row][i]);
    where[col] = row;
    for (int i=0; i&lt;n; ++i) 
      if (i != row) {
        int c = (a[i][col] * inv[a[row][col]]) % MOD;
        for (int j=col; j&lt;=m; ++j)
          a[i][j] = (a[i][j] - (a[row][j]*c % MOD) + MOD) % MOD;
      }
    ++row;
  }

  ans.assign (m, 0);
  for (int i=0; i&lt;m; ++i)
    if (where[i] != -1)
      ans[i] = (a[where[i]][m] * inv[a[where[i]][i]]) % MOD;
  for (int i=0; i&lt;n; ++i) {
    int sum = 0;
    for (int j=0; j&lt;m; ++j)
      sum = (MOD + sum + (ans[j] * a[i][j]) % MOD) % MOD;
    if (abs (sum - a[i][m]) != 0)
      return 0;
  }
  for (int i=0; i&lt;m; ++i)
    if (where[i] == -1) return INF;
  return 1;
}


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  string ns; getline(cin, ns); int n = stoi(ns);
  string s1; getline(cin, s1); 
  string s2; getline(cin, s2);
  vector&lt;ll&gt; inv(MOD);
  inv[1]=1;
  for(int i = 2; i &lt; MOD; ++i) inv[i] = MOD - (MOD/i) * inv[MOD % i] % MOD;
  vector&lt; vector &lt;int&gt; &gt; v1( n , vector &lt;int&gt; ()); 
  vector&lt; vector &lt;int&gt; &gt; v2( n , vector &lt;int&gt; ()); 
  for(int i = 0; i &lt; s1.size(); i++) {
    int num;
    if(s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'Z') {
      num = int(s1[i]) - 65;
    }
    else if(s1[i] == ' ') num = 36;
    else num = (s1[i] - '0') + 26;
    v1[i % n].push_back(num);
  }  
  for(int i = 0; i &lt; s2.size(); i++) {
    int num;
    if(s2[i] &gt;= 'A' &amp;&amp; s2[i] &lt;= 'Z') {
      num = int(s2[i]) - 65;
    }
    else if(s2[i] == ' ') num = 36;
    else num = (s2[i] - '0') + 26;
    v2[i % n].push_back(num);
  }
  int consistent = 0;
  int many = 0;
  int no = 0;
  vector &lt;vector &lt;int&gt; &gt; sol;
  for(int i = 0; i &lt; n; i++) {
    vector&lt;vector&lt;int&gt;&gt;a(v1[0].size(), vector&lt;int&gt;(n + 1));
    vector&lt;int&gt;b(n);
    for(int j = 0; j &lt; v1[0].size(); j++) {
      for(int k = 0; k &lt; n; k++) {
        a[j][k] = v1[k][j];
      }
      a[j][n] = v2[i][j]; 
    }
    vector&lt;int&gt;ans;
    int num = gauss(a, ans, inv);
    if(num == 0) no++;
    else if(num == 1) {
      consistent++;
      sol.push_back(ans);
    }
    else many++;
  }
  if(consistent == n) print2d(sol, n, n);
  else if(no &gt;= 1)cout &lt;&lt; "No solution" &lt;&lt; endl;
  else if(many &gt;= 1) cout &lt;&lt; "Too many solutions" &lt;&lt; endl;
  return 0;
}
</pre>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-G"><h3 id="G" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-G">G</a></h3></div>

<p>
直接模拟即可
</p>

<pre>
#include &lt;bits/stdc++.h&gt;

#define all(x) (x).begin(),(x).end()
#define sz(x) int(x.size())

using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
template&lt;typename... T&gt; void rd(T&amp;... args) {((cin&gt;&gt;args), ...);}
template&lt;typename... T&gt; void wr(T... args) {((cout&lt;&lt;args&lt;&lt;" "), ...); cout&lt;&lt;'\n';}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    cin&gt;&gt;n&gt;&gt;m;
    vector&lt;int&gt; a(n), rank(n);
    iota(all(a), 0);
    iota(all(rank), 0);
    while (m--) {
        char c;
        int u, v;
        cin&gt;&gt;c&gt;&gt;u&gt;&gt;c&gt;&gt;v;
        u--, v--;
        if (rank[u]&gt;rank[v]) {
            for (int i=rank[v]; i&lt;rank[u]; i++) {
                a[i]=a[i+1];
                rank[a[i]]=i;
            }
            a[rank[u]+1]=v;
            rank[v]=rank[u]+1;
        }
    }
    for (auto i : a) cout&lt;&lt;"T"&lt;&lt;i+1&lt;&lt;' ';
    return 0;
}
</pre>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-H"><h3 id="H" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-H">H</a></h3></div>

<p>
根据deadline排序，然后维护有多少槽位可供不需要纸的和需要纸的人用（代码里的<code>have</code>数组）,不需要纸的人也可以用需要纸的人的槽位。然后根据人数相应的更新数组。
</p>

<p>
队友的赛时的源代码
</p>

<pre>
from collections import *
from functools import *
from math import *
import sys

input = sys.stdin.readline
sys.setrecursionlimit(2147483647)
ml = lambda: map(int, input().split())

s, n = ml()
people = defaultdict(lambda: [0, 0])
for _ in range(n):
    deadline, need = input().split()
    deadline = int(deadline)
    people[deadline][need[0] == "y"] += 1

have = [0, 0]
prev = 0
for deadline in sorted(people.keys()):
    have[1] += deadline - prev
    have[0] += (deadline - prev) * (s - 1)
    prev = deadline

    dont, need = people[deadline]

    do = min(dont, have[0])
    dont -= do
    have[0] -= do

    if dont + need &gt; have[1]:
        print("No")
        break
    have[1] -= dont + need
else:
    print("Yes")
</pre>

<p>
我用C++又写了一遍:
</p>

<pre>
#include &lt;bits/stdc++.h&gt;

#define all(x) (x).begin(),(x).end()
#define sz(x) int(x.size())

using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
template&lt;typename... T&gt; void rd(T&amp;... args) {((cin&gt;&gt;args), ...);}
template&lt;typename... T&gt; void wr(T... args) {((cout&lt;&lt;args&lt;&lt;" "), ...); cout&lt;&lt;'\n';}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int s, n;
    cin&gt;&gt;s&gt;&gt;n;
    map&lt;int, array&lt;int, 2&gt;&gt; people;
    for (int i=0; i&lt;n; i++) {
        int deadline;
        char need;
        cin&gt;&gt;deadline&gt;&gt;need;
        people[deadline][need=='y']++;
    }
    ll have[2]{};
    int prev=0;
    for (auto&amp; [deadline, v] : people) {
        have[1]+=deadline-prev;
        have[0]+=ll(deadline-prev)*(s-1);
        prev=deadline;

        auto [dont, need]=v;

        int Do=min&lt;ll&gt;(dont, have[0]);
        dont-=Do;
        have[0]-=Do;
        if (dont+need&gt;have[1]) {
            return cout&lt;&lt;"No\n", 0;
        }
        have[1]-=dont+need;
    }
    cout&lt;&lt;"Yes\n";
    return 0;
}
</pre>
<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-I"><h3 id="I" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-I">I</a></h3></div>

<p>
还没补
</p>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-J"><h3 id="J" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-J">J</a></h3></div>

<p>
根据题意模拟即可
</p>

<pre>
#include &lt;bits/stdc++.h&gt;

#define all(x) (x).begin(),(x).end()
#define sz(x) int(x.size())

using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
template&lt;typename... T&gt; void rd(T&amp;... args) {((cin&gt;&gt;args), ...);}
template&lt;typename... T&gt; void wr(T... args) {((cout&lt;&lt;args&lt;&lt;" "), ...); cout&lt;&lt;'\n';}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    vector a(9, vector(9, 0));
    for (auto&amp; v: a) for (auto&amp; i : v) cin&gt;&gt;i;
    auto check_row=[&amp;](int row, auto&amp; cnt, int x) {
        for (int i=0; i&lt;9; i++) {
            cnt[row][i][x]=0;
        }
    };
    auto check_col=[&amp;](int col, auto&amp; cnt, int x) {
        for (int i=0; i&lt;9; i++) {
            cnt[i][col][x]=0;
        }
    };
    auto check_grid=[&amp;](int r, int c, auto&amp; cnt, int x) {
        int num=r/3*3+c/3;
        r=num/3*3, c=num%3*3;
        for (int i=r; i&lt;r+3; i++) {
            for (int j=c; j&lt;c+3; j++) {
                cnt[i][j][x]=0;
            }
        }
    };
    auto count_row=[&amp;](int row, auto&amp; cnt, int x) {
        int c=0;
        for (int i=0; i&lt;9; i++) {
            if (a[row][i]) continue;
            c+=cnt[row][i][x];
        }
        return c;
    };
    auto count_col=[&amp;](int col, auto&amp; cnt, int x) {
        int c=0;
        for (int i=0; i&lt;9; i++) {
            if (a[i][col]) continue;
            c+=cnt[i][col][x];
        }
        return c;
    };
    auto count_grid=[&amp;](int r, int c, auto&amp; cnt, int x) {
        int num=r/3*3+c/3;
        r=num/3*3, c=num%3*3;
        int cc=0;
        for (int i=r; i&lt;r+3; i++) {
            for (int j=c; j&lt;c+3; j++) {
                if (a[i][j]) continue;
                cc+=cnt[i][j][x];
            }
        }
        return cc;
    };
    while (true) {
        int found=0;
        vector cnt(9, vector(9, vector(10, 1)));
        for (int i=0; i&lt;9; i++) {
            for (int j=0; j&lt;9; j++) {
                cnt[i][j][0]=0;
                if (a[i][j]!=0) {
                    check_col(j, cnt, a[i][j]);
                    check_row(i, cnt, a[i][j]);
                    check_grid(i, j, cnt, a[i][j]);
                }
            }
        }
        for (int i=0; i&lt;9; i++) {
            for (int j=0; j&lt;9; j++) {
                if (a[i][j]==0) {
                    if (count(all(cnt[i][j]), 1)==1) {
                        found=1;
                        auto it=find(all(cnt[i][j]), 1);
                        a[i][j]=it-cnt[i][j].begin();
                        goto next;
                    }
                    for (int v=1; v&lt;=9; v++) {
                        if ((count_col(j, cnt, v)==1 || count_row(i, cnt, v)==1 || count_grid(i, j, cnt, v)==1) &amp;&amp; cnt[i][j][v]) {
                            found=1;
                            a[i][j]=v;
                            goto next;
                        }
                    }
                }
            }
        }
next:
        if (found==0) break;
    }
    int cc=0;
    for (auto&amp; v : a) for (auto i : v) cc+=i==0;
    if (cc) {
        cout&lt;&lt;"Not easy\n";
        for (auto&amp; v : a) {
            for (auto&amp; i : v) {
                if (i==0) cout&lt;&lt;'.';
                else cout&lt;&lt;i;
                cout&lt;&lt;' ';
            }
            cout&lt;&lt;'\n';
        }
    } else {
        cout&lt;&lt;"Easy\n";
        for (auto&amp; v : a) {
            for (auto i : v) cout&lt;&lt;i&lt;&lt;' ';
            cout&lt;&lt;'\n';
        }
    }
    return 0;
}
</pre>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-K"><h3 id="K" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-K">K</a></h3></div>

<p>
我们可以用一次实验把当前问题变成两个更小的子问题，假设当前的最大高度是<code>h</code>, 还剩<code>n</code>个pallet，如果我们用<code>x</code>个箱子试一次，如果pallet坏了的话那么问题就变成了：最大高度为<code>h-1</code>, 还剩<code>n-1</code>个pallet；如果没坏的话问题就变成了高度为<code>h-x</code>，还剩<code>x</code>个pallet。所以我们可以用dp。求范围的过程与dp类似。
</p>

<pre>
#include &lt;bits/stdc++.h&gt;

#define all(x) (x).begin(),(x).end()
#define sz(x) int(x.size())

using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
template&lt;typename... T&gt; void rd(T&amp;... args) {((cin&gt;&gt;args), ...);}
template&lt;typename... T&gt; void wr(T... args) {((cout&lt;&lt;args&lt;&lt;" "), ...); cout&lt;&lt;'\n';}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    cin&gt;&gt;n&gt;&gt;m;
    vector need(n+1, vector(m+1, 0));
    for (int i=0; i&lt;=n; i++) need[i][1]=i;

    for (int i=1; i&lt;=n; i++) {
        for (int pallet=2; pallet&lt;=m; pallet++) {
            int mn=n+1;
            for (int j=1; j&lt;=i; j++) {
                int v1=need[j-1][pallet-1], v2=need[i-j][pallet];
                mn=min(mn, max(v1, v2));
            }
            need[i][pallet]=mn+1;
        }
    }
    int l=n, r=0;
    int ans=need[n][m];
    for (int i=1; i&lt;=n; i++) {
        if (max(need[i-1][m-1], need[n-i][m])+1==ans){
            l=min(l, i);
            r=max(r, i);
        }
    }
    cout&lt;&lt;ans&lt;&lt;' ';
    if (l==r) cout&lt;&lt;l;
    else cout&lt;&lt;l&lt;&lt;'-'&lt;&lt;r;
    return 0;
}
</pre>

<p>
队友的二分做法：（和扔鸡蛋问题类似）
</p>

<pre>
from collections import *
from functools import *
from math import *
import sys

input = sys.stdin.readline
sys.setrecursionlimit(2147483647)
ml = lambda: map(int, input().split())

def binomialCoeff(x, n, k):
    sum = 0
    term = 1
    i = 1
    while (i &lt;= n and sum &lt; k):
        term *= x - i + 1
        term /= i
        sum += term
        i += 1
    return sum

def minTrials(eggs, floors):
    if eggs == 0:
        return floors and inf
    low = 1
    high = floors

    while low &lt; high:
        mid = low + high &gt;&gt; 1
        if binomialCoeff(mid, eggs, floors) &lt; floors:
            low = mid + 1
        else:
            high = mid

    return low

def findX(eggs, floors):
    low = 1
    high = floors

    while low &lt; high:
        mid = low + high &gt;&gt; 1
        if minTrials(eggs, floors - mid) &lt;= ans - 1:
            high = mid
        else:
            low = mid + 1

    return low


def findY(eggs, floors):
    low = 1
    high = floors

    while low &lt; high:
        mid = low + high + 1 &gt;&gt; 1
        if minTrials(eggs - 1, mid - 1) &lt;= ans - 1:
            low = mid
        else:
            high = mid - 1

    return low

# range: x to y
floors, eggs = ml()
n = floors
m = eggs
# worst case: doesn't break on x and breaks on y
# find smallest x s.t. minTrials(floors - x, eggs) &lt;= ans - 1
# find biggest y s.t. minTrials(y - 1, eggs - 1) &lt;= ans - 1

ans = minTrials(eggs, floors)
x = findX(eggs, floors)
y = findY(eggs, floors)

if x == y:
    print(ans, x)
else:
    print(ans, str(x) + "-" + str(y))
</pre>

<div id="2020 ICPC East Central NA Regional Contest 总结与题解-题解-L"><h3 id="L" class="header"><a href="#2020 ICPC East Central NA Regional Contest 总结与题解-题解-L">L</a></h3></div>

<p>
可以观察到一定是上面的几个门用A通道，剩下下面的用B通道，所以可以枚举A和B分界的位置，然后剩下的问题就是公寓匹配门、门匹配工作站了，跑两次二分图最大权匹配即可。之前做过匹配的题的话这题应该是很简单的，可以当时没人读到，但队友读了也不一定能反应过来是匹配问题233。
</p>

<pre>
#include &lt;bits/stdc++.h&gt;

#define all(x) (x).begin(),(x).end()
#define sz(x) int(x.size())

using namespace std;
using ll = long long;
using pii = pair&lt;int, int&gt;;
template&lt;typename... T&gt; void rd(T&amp;... args) {((cin&gt;&gt;args), ...);}
template&lt;typename... T&gt; void wr(T... args) {((cout&lt;&lt;args&lt;&lt;" "), ...); cout&lt;&lt;'\n';}

template&lt;typename T&gt;
class Hungarian {
public:
    int n, m;
    vector&lt; vector&lt;T&gt; &gt; a;
    vector&lt;T&gt; u, v;
    vector&lt;int&gt; pa, pb, way;
    vector&lt;T&gt; minv;
    vector&lt;bool&gt; used;
    T inf;
    Hungarian(int _n, int _m) : n(_n), m(_m), a(n, vector&lt;T&gt;(m)), u(n+1), v(m+1), pa(n+1, -1), pb(m+1, -1), way(m, -1), minv(m), used(m+1) {
        assert(n &lt;= m);
        inf = numeric_limits&lt;T&gt;::max();
    }
    inline void add_row(int i) {
        fill(minv.begin(), minv.end(), inf);
        fill(used.begin(), used.end(), false);
        pb[m] = i;
        pa[i] = m;
        int j0 = m;
        do {
            used[j0] = true;
            int i0 = pb[j0];
            T delta = inf;
            int j1 = -1;
            for (int j = 0; j &lt; m; j++) {
                if (!used[j]) {
                    T cur = a[i0][j] - u[i0] - v[j];
                    if (cur &lt; minv[j]) {
                        minv[j] = cur;
                        way[j] = j0;
                    }
                    if (minv[j] &lt; delta) {
                        delta = minv[j];
                        j1 = j;
                    }
                }
            }
            for (int j = 0; j &lt;= m; j++) {
                if (used[j]) {
                    u[pb[j]] += delta;
                    v[j] -= delta;
                } else {
                    minv[j] -= delta;
                }
            }
            j0 = j1;
        } while (pb[j0] != -1);
        do {
            int j1 = way[j0];
            pb[j0] = pb[j1];
            pa[pb[j0]] = j0;
            j0 = j1;
        } while (j0 != m);
    }
    inline T current_score() {
        return -v[m];
    }
    inline T solve() {
        for (int i = 0; i &lt; n; i++) {
            add_row(i);
        }
        return current_score();
    }
};
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin&gt;&gt;n;
    vector g1(n, vector(2*n, 0));
    auto g2=g1;
    for (auto&amp; v : g1)
        for (auto&amp; i : v) cin&gt;&gt;i;
    for (auto&amp; v : g2)
        for (auto&amp; i : v) cin&gt;&gt;i;
    int mn_cost=1e9;
    vector&lt;array&lt;int, 3&gt;&gt; ans(n);
    for (int i=-1; i&lt;n; i++) {
        vector ng1(n, vector(n, 0));
        auto ng2=ng1;
        for (int j=0; j&lt;n; j++) {
            for (int u=0; u&lt;n; u++) {
                ng1[u][j]=g1[u][j*2+(j&gt;i)];
                ng2[u][j]=g2[u][j*2+(j&gt;i)];
            }
        }
        Hungarian&lt;int&gt; h1(n, n), h2(n, n);
        h1.a=ng1, h2.a=ng2;
        if (int cur=h1.solve() + h2.solve(); cur &lt;mn_cost) {
            mn_cost=cur;
            for (int j=0; j&lt;n; j++) {
                ans[j]={j, h1.pa[j]*2+(h1.pa[j]&gt;i),h2.pb[h1.pa[j]]};
            }
        }
    }
    cout&lt;&lt;mn_cost&lt;&lt;'\n';
    for (auto [x, y , z] : ans) {
        cout&lt;&lt;x+1&lt;&lt;' '&lt;&lt;y/2+1&lt;&lt;char('A'+y%2)&lt;&lt;' '&lt;&lt;z+1&lt;&lt;'\n';
    }
    return 0;
}
</pre>

</body>
</html>
